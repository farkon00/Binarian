// Input 
set i [0]
set initial []
while {not {eq i [0 1 0 1]}} (
    set i {add i [1]}
    input inp
    append initial inp
)

set states [initial]

set last-state initial
set i [0]
while {not {eq i [1 0 0 1]}} (
    set j [1]
    set new-state [0]
    while {not {eq j [1 0 0 1]}} (
        set p {index last-state {subt j [1]}}
        set q {index last-state j}
        set r {index last-state {add j [1]}}
        append new-state {or {and q {not p}} {xor q r}}
    )
    append new-state 0
    set last-state new-state
    append states last-state
)

for i states (
    output i state
)